import React, { useRef, useEffect, useState } from 'react';
import { GameEngine } from '../engine/GameEngine';
import { MinimalGameEngine } from '../engine/MinimalGameEngine';
import { useGameStore } from '../store/gameStore';
import GameInterface from './GameInterface';
import CombatUI from './CombatUI';
import type { FloatingText, HealthBar } from './CombatUI';
import * as THREE from 'three';

const Game: React.FC = () => {
  const gameContainerRef = useRef<HTMLDivElement>(null);
  const gameEngineRef = useRef<GameEngine | MinimalGameEngine | null>(null);
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string>('');
  const [loadingStep, setLoadingStep] = useState<string>('Initializing...');
  
  const { setGameLoaded, addExperience } = useGameStore();
  
  // Use minimal engine for testing
  const useMinimalEngine = false;

  // Camera controls  
  const keysPressed = useRef<Set<string>>(new Set());
  const cameraRotationSpeed = 0.02;
  const [targetPosition, setTargetPosition] = useState<THREE.Vector3 | null>(null);
  const [isMoving, setIsMoving] = useState(false);
  const [clickIndicator, setClickIndicator] = useState<{x: number, y: number, show: boolean}>({x: 0, y: 0, show: false});
  const [contextMenu, setContextMenu] = useState<{x: number, y: number, show: boolean, npc?: any}>({x: 0, y: 0, show: false});
  
  // Combat UI state
  const [floatingTexts, setFloatingTexts] = useState<FloatingText[]>([]);
  const [healthBars, setHealthBars] = useState<HealthBar[]>([]);

  // Helper function to add floating text
  const addFloatingText = (text: string, type: 'damage' | 'miss' | 'xp' | 'heal', screenX: number, screenY: number) => {
    const newText: FloatingText = {
      id: `${Date.now()}_${Math.random()}`,
      text,
      type,
      x: screenX,
      y: screenY,
      timestamp: Date.now()
    };
    setFloatingTexts(prev => [...prev, newText]);
  };

  // Helper function to remove floating text
  const removeFloatingText = (id: string) => {
    setFloatingTexts(prev => prev.filter(text => text.id !== id));
  };

  // Helper function to update health bars
  const updateHealthBar = (id: string, name: string, currentHealth: number, maxHealth: number, screenX: number, screenY: number, isPlayer: boolean = false) => {
    const newHealthBar: HealthBar = {
      id,
      name,
      currentHealth,
      maxHealth,
      x: screenX,
      y: screenY,
      isPlayer
    };
    
    setHealthBars(prev => {
      const filtered = prev.filter(bar => bar.id !== id);
      return [...filtered, newHealthBar];
    });
  };

  // Helper function to remove health bar
  const removeHealthBar = (id: string) => {
    setHealthBars(prev => prev.filter(bar => bar.id !== id));
  };

  // Helper function to get screen position from world position
  const getScreenPosition = (worldPosition: THREE.Vector3): { x: number, y: number } => {
    if (!gameEngineRef.current || useMinimalEngine) return { x: 0, y: 0 };
    
    const engine = gameEngineRef.current as GameEngine;
    const camera = engine.getCamera();
    const renderer = engine.getRenderer();
    
    if (!camera || !renderer) return { x: 0, y: 0 };

    const vector = worldPosition.clone();
    vector.project(camera);

    const canvas = renderer.domElement;
    const x = (vector.x * 0.5 + 0.5) * canvas.clientWidth;
    const y = (vector.y * -0.5 + 0.5) * canvas.clientHeight;

    return { x, y };
  };

  useEffect(() => {
    if (!gameContainerRef.current) return;

    console.log('Initializing game with container:', gameContainerRef.current);

    try {
      setLoadingStep('Creating game engine...');
      if (!gameContainerRef.current) {
        throw new Error('Container not found');
      }
      
      if (useMinimalEngine) {
        console.log('Using minimal engine...');
        gameEngineRef.current = new MinimalGameEngine(gameContainerRef.current);
      } else {
        console.log('Using full game engine...');
        gameEngineRef.current = new GameEngine(gameContainerRef.current);
      }
      console.log('GameEngine created successfully');
      
      setLoadingStep('Starting game loop...');
      gameEngineRef.current.start();
      console.log('GameEngine started');
      
      // Test rendering after a short delay
      setTimeout(() => {
        console.log('Testing render after 1 second...');
        if (gameEngineRef.current && !useMinimalEngine) {
          console.log('Full engine renderer test completed');
        }
      }, 1000);
      
      // Complete initialization immediately for minimal engine
      setLoadingStep('Loading complete!');
      setGameLoaded(true);
      setIsLoaded(true);
      setHasError(false);
      console.log('Game initialization complete');
    } catch (error) {
      console.error('Failed to initialize game:', error);
      setErrorMessage(error instanceof Error ? error.message : 'Unknown error');
      setHasError(true);
      setIsLoaded(false);
    }

    return () => {
      if (gameEngineRef.current) {
        gameEngineRef.current.dispose();
      }
    };
  }, [setGameLoaded]);

  // Handle keyboard input (camera rotation)
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      keysPressed.current.add(event.key.toLowerCase());
    };

    const handleKeyUp = (event: KeyboardEvent) => {
      keysPressed.current.delete(event.key.toLowerCase());
    };

    // Camera rotation update loop
    const updateCamera = () => {
      if (!gameEngineRef.current || useMinimalEngine) return;

      const engine = gameEngineRef.current as GameEngine;
      
      if (keysPressed.current.has('a') || keysPressed.current.has('arrowleft')) {
        engine.rotateCamera(-cameraRotationSpeed);
      }
      if (keysPressed.current.has('d') || keysPressed.current.has('arrowright')) {
        engine.rotateCamera(cameraRotationSpeed);
      }

      requestAnimationFrame(updateCamera);
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    updateCamera();

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [cameraRotationSpeed]);

  // Handle mouse clicks (movement, NPC interaction, and context menus)
  useEffect(() => {
    const handleClick = (event: MouseEvent) => {
      if (!gameEngineRef.current || useMinimalEngine) return;
      
      const container = gameContainerRef.current;
      if (!container) return;

      // Close any open context menu
      setContextMenu({x: 0, y: 0, show: false});

      const engine = gameEngineRef.current as GameEngine;
      const rect = container.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      // Show click feedback
      setClickIndicator({x: mouseX, y: mouseY, show: true});
      setTimeout(() => setClickIndicator(prev => ({...prev, show: false})), 500);

      // First check if we clicked an NPC
      const clickedNPC = engine.getClickedNPC(mouseX, mouseY, rect.width, rect.height);
      if (clickedNPC) {
        const npcName = clickedNPC.userData.name;
        console.log(`Left-clicked NPC: ${npcName} - Attacking!`);
        
        // Move to NPC and attack
        const npcPos = clickedNPC.position.clone();
        npcPos.x += 1.5; // Stand close to NPC for combat
        engine.movePlayerTo(npcPos);
        setTargetPosition(npcPos);
        setIsMoving(true);
        
        // Start combat after reaching NPC
        setTimeout(() => {
          const playerStats = useGameStore.getState().getCombatStats();
          const combatStyle = useGameStore.getState().combatStyle;
          // Check if already in combat
          if (engine.isInCombat()) {
            engine.stopCombat();
          }
          
          // Start continuous combat
          engine.startCombat(clickedNPC, playerStats, combatStyle, (event: any) => {
          
          if (combatResult.success) {
            let message = `ðŸ’¥ You hit the ${npcName} for ${combatResult.damage} damage!`;
            
            if (combatResult.npcDead) {
              message += `\n\nï¿½ You have defeated the ${npcName}!`;
            }
            
            // Add experience gained
            const xp = combatResult.xp;
            message += `\n\nðŸ“ˆ Experience Gained:`;
            if (xp.attack > 0) message += `\n+${xp.attack} Attack XP`;
            if (xp.strength > 0) message += `\n+${xp.strength} Strength XP`;
            if (xp.defense > 0) message += `\n+${xp.defense} Defense XP`;
            if (xp.hits > 0) message += `\n+${xp.hits} Hits XP`;
            
            // Apply XP to game store
            if (xp.attack > 0) addExperience('attack', xp.attack);
            if (xp.strength > 0) addExperience('strength', xp.strength);
            if (xp.defense > 0) addExperience('defense', xp.defense);
            if (xp.hits > 0) addExperience('hits', xp.hits);
            
            // Get screen position for floating text
            const npcScreenPos = getScreenPosition(clickedNPC.position);
            
            // Show damage number above NPC
            addFloatingText(`${combatResult.damage}`, 'damage', npcScreenPos.x, npcScreenPos.y - 20);
            
            // Show XP gains with slight delay and offset
            let xpMessages: string[] = [];
            if (xp.attack > 0) xpMessages.push(`+${xp.attack} Att`);
            if (xp.strength > 0) xpMessages.push(`+${xp.strength} Str`);
            if (xp.defense > 0) xpMessages.push(`+${xp.defense} Def`);
            if (xp.hits > 0) xpMessages.push(`+${xp.hits} HP`);
            
            xpMessages.forEach((msg, index) => {
              setTimeout(() => {
                addFloatingText(msg, 'xp', npcScreenPos.x + (index * 30 - 45), npcScreenPos.y - 40);
              }, 300 + index * 100);
            });
            
            // Update health bar for NPC
            const npcStats = clickedNPC.userData.stats;
            updateHealthBar(
              `npc_${clickedNPC.id}`, 
              npcName, 
              npcStats.currentHits || 0, 
              npcStats.hits || 10, 
              npcScreenPos.x, 
              npcScreenPos.y
            );
            
            if (combatResult.npcDead) {
              // Remove health bar when NPC dies
              setTimeout(() => {
                removeHealthBar(`npc_${clickedNPC.id}`);
              }, 2000);
            }
          } else {
            // Get screen position for floating text
            const npcScreenPos = getScreenPosition(clickedNPC.position);
            // Show miss text
            addFloatingText('Miss!', 'miss', npcScreenPos.x, npcScreenPos.y - 20);
          }
        }, 1000);
        
        return;
      }

      // Check if we clicked a tree
      const clickedTree = engine.getClickedTree(mouseX, mouseY, rect.width, rect.height);
      if (clickedTree) {
        console.log('Clicked tree - starting woodcutting');
        
        // Move to tree and start woodcutting
        const treePos = clickedTree.position.clone();
        treePos.x += 2; // Stand next to tree
        engine.movePlayerTo(treePos);
        setTargetPosition(treePos);
        setIsMoving(true);
        
        // Start woodcutting after reaching tree
        setTimeout(() => {
          // Get screen position for floating text
          const treeScreenPos = getScreenPosition(clickedTree.position);
          
          // Apply woodcutting XP to game store
          addExperience('woodcutting', 25);
          
          // Show woodcutting XP
          addFloatingText('+25 Woodcutting XP', 'xp', treeScreenPos.x, treeScreenPos.y - 30);
          
          // Show logs gained
          setTimeout(() => {
            addFloatingText('+1 Logs', 'heal', treeScreenPos.x, treeScreenPos.y - 50);
          }, 500);
        }, 1000);
        
        return;
      }

      // If no interactive object clicked, move to ground
      const groundPos = engine.getGroundPosition(mouseX, mouseY, rect.width, rect.height);
      if (groundPos) {
        // Start smooth movement to clicked position
        engine.movePlayerTo(groundPos);
        setTargetPosition(groundPos);
        setIsMoving(true);
      }
    };

    const handleRightClick = (event: MouseEvent) => {
      event.preventDefault(); // Prevent browser context menu
      
      if (!gameEngineRef.current || useMinimalEngine) return;
      
      const container = gameContainerRef.current;
      if (!container) return;

      const engine = gameEngineRef.current as GameEngine;
      const rect = container.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      // Check if we right-clicked an NPC
      const clickedNPC = engine.getClickedNPC(mouseX, mouseY, rect.width, rect.height);
      if (clickedNPC) {
        // Show context menu
        setContextMenu({
          x: event.clientX,
          y: event.clientY,
          show: true,
          npc: clickedNPC
        });
        return;
      }

      // Check if we right-clicked a tree
      const clickedTree = engine.getClickedTree(mouseX, mouseY, rect.width, rect.height);
      if (clickedTree) {
        // Show tree context menu
        setContextMenu({
          x: event.clientX,
          y: event.clientY,
          show: true,
          npc: { userData: { name: 'Tree', type: 'tree' }, position: clickedTree.position }
        });
        return;
      }
    };

    const container = gameContainerRef.current;
    if (container) {
      container.addEventListener('click', handleClick);
      container.addEventListener('contextmenu', handleRightClick);
      container.style.cursor = 'pointer';

      return () => {
        container.removeEventListener('click', handleClick);
        container.removeEventListener('contextmenu', handleRightClick);
      };
    }
  }, [setTargetPosition, setIsMoving]);

  // Close context menu when clicking elsewhere
  useEffect(() => {
    const handleDocumentClick = () => {
      setContextMenu({x: 0, y: 0, show: false});
    };

    if (contextMenu.show) {
      document.addEventListener('click', handleDocumentClick);
      return () => document.removeEventListener('click', handleDocumentClick);
    }
  }, [contextMenu.show]);

  // Handle context menu actions
  const handleContextAction = (action: string, npc: any) => {
    setContextMenu({x: 0, y: 0, show: false});
    
    if (!gameEngineRef.current || useMinimalEngine) return;
    const engine = gameEngineRef.current as GameEngine;

    if (npc.userData.type === 'tree') {
      if (action === 'chop') {
        const treePos = npc.position.clone();
        treePos.x += 2;
        engine.movePlayerTo(treePos);
        setTargetPosition(treePos);
        setIsMoving(true);
        
        setTimeout(() => {
          // Get screen position for floating text
          const treeScreenPos = getScreenPosition(npc.position);
          
          // Apply woodcutting XP to game store
          addExperience('woodcutting', 25);
          
          // Show woodcutting XP
          addFloatingText('+25 Woodcutting XP', 'xp', treeScreenPos.x, treeScreenPos.y - 30);
          
          // Show logs gained
          setTimeout(() => {
            addFloatingText('+1 Logs', 'heal', treeScreenPos.x, treeScreenPos.y - 50);
          }, 500);
        }, 1000);
      }
      return;
    }

    // Handle NPC actions
    const npcPos = npc.position.clone();
    
    switch (action) {
      case 'talk':
        npcPos.x += 1;
        engine.movePlayerTo(npcPos);
        setTargetPosition(npcPos);
        setIsMoving(true);
        
        setTimeout(() => {
          const npcName = npc.userData.name;
          let dialogue = `${npcName}: "Hello there, adventurer!"`;
          
          if (npcName === 'Goblin') dialogue = `${npcName}: "Grrr! What you want?"`;
          else if (npcName === 'Cow') dialogue = `${npcName}: "Moo! *chews grass peacefully*"`;
          else if (npcName === 'Chicken') dialogue = `${npcName}: "Bawk bawk! *pecks at ground*"`;
          else if (npcName === 'Rat') dialogue = `${npcName}: "*squeaks and scurries*"`;
          
          alert(dialogue);
        }, 1000);
        break;
        
      case 'attack':
        npcPos.x += 1.5;
        engine.movePlayerTo(npcPos);
        setTargetPosition(npcPos);
        setIsMoving(true);
        
        setTimeout(() => {
          const npcName = npc.userData.name;
          const playerStats = useGameStore.getState().getCombatStats();
          const combatStyle = useGameStore.getState().combatStyle;
          const combatResult = engine.attackNPC(npc, playerStats, combatStyle);
          
          if (combatResult.success) {
            let message = `ðŸ’¥ You hit the ${npcName} for ${combatResult.damage} damage!`;
            
            if (combatResult.npcDead) {
              message += `\n\nï¿½ You have defeated the ${npcName}!`;
            }
            
            // Add experience gained
            const xp = combatResult.xp;
            message += `\n\nðŸ“ˆ Experience Gained:`;
            if (xp.attack > 0) message += `\n+${xp.attack} Attack XP`;
            if (xp.strength > 0) message += `\n+${xp.strength} Strength XP`;
            if (xp.defense > 0) message += `\n+${xp.defense} Defense XP`;
            if (xp.hits > 0) message += `\n+${xp.hits} Hits XP`;
            
            // Apply XP to game store
            if (xp.attack > 0) addExperience('attack', xp.attack);
            if (xp.strength > 0) addExperience('strength', xp.strength);
            if (xp.defense > 0) addExperience('defense', xp.defense);
            if (xp.hits > 0) addExperience('hits', xp.hits);
            
            // Get screen position for floating text
            const npcScreenPos = getScreenPosition(npc.position);
            
            // Show damage number above NPC
            addFloatingText(`${combatResult.damage}`, 'damage', npcScreenPos.x, npcScreenPos.y - 20);
            
            // Show XP gains with slight delay and offset
            let xpMessages: string[] = [];
            if (xp.attack > 0) xpMessages.push(`+${xp.attack} Att`);
            if (xp.strength > 0) xpMessages.push(`+${xp.strength} Str`);
            if (xp.defense > 0) xpMessages.push(`+${xp.defense} Def`);
            if (xp.hits > 0) xpMessages.push(`+${xp.hits} HP`);
            
            xpMessages.forEach((msg, index) => {
              setTimeout(() => {
                addFloatingText(msg, 'xp', npcScreenPos.x + (index * 30 - 45), npcScreenPos.y - 40);
              }, 300 + index * 100);
            });
            
            // Update health bar for NPC
            const npcStats = npc.userData.stats;
            updateHealthBar(
              `npc_${npc.id}`, 
              npcName, 
              npcStats.currentHits || 0, 
              npcStats.hits || 10, 
              npcScreenPos.x, 
              npcScreenPos.y
            );
            
            if (combatResult.npcDead) {
              // Remove health bar when NPC dies
              setTimeout(() => {
                removeHealthBar(`npc_${npc.id}`);
              }, 2000);
            }
          } else {
            // Get screen position for floating text
            const npcScreenPos = getScreenPosition(npc.position);
            // Show miss text
            addFloatingText('Miss!', 'miss', npcScreenPos.x, npcScreenPos.y - 20);
          }
        }, 1000);
        break;
        
      case 'examine':
        const npcName = npc.userData.name;
        let examineText = `It's a ${npcName}.`;
        
        if (npcName === 'Goblin') examineText = "A small, green, and very ugly humanoid.";
        else if (npcName === 'Cow') examineText = "A dairy cow. Holy cow!";
        else if (npcName === 'Chicken') examineText = "A farmyard chicken.";
        else if (npcName === 'Rat') examineText = "Yuck, a rat!";
        
        alert(examineText);
        break;
    }
  };

  // Force loaded state for testing
  const forceLoaded = true;

  if (hasError) {
    return (
      <div className="game-error">
        <h2>Failed to Initialize Game</h2>
        <p>{errorMessage}</p>
        <p>Your browser may not support WebGL or Three.js</p>
        <p>Please try:</p>
        <ul>
          <li>Using a modern browser (Chrome, Firefox, Safari, Edge)</li>
          <li>Enabling hardware acceleration</li>
          <li>Updating your graphics drivers</li>
        </ul>
      </div>
    );
  }

  if (!isLoaded && !forceLoaded) {
    return (
      <div className="game-loading">
        <h2>Loading RuneScape Classic...</h2>
        <p>{loadingStep}</p>
      </div>
    );
  }

  return (
    <div className="game-container">
      <div 
        ref={gameContainerRef}
        className="game-canvas"
        style={{
          width: '100vw',
          height: '100vh',
          position: 'relative',
          background: '#000',
          overflow: 'hidden'
        }}
      />
      
      {/* Click feedback indicator */}
      {clickIndicator.show && (
        <div style={{
          position: 'absolute',
          left: clickIndicator.x - 10,
          top: clickIndicator.y - 10,
          width: '20px',
          height: '20px',
          border: '2px solid #ffff00',
          borderRadius: '50%',
          pointerEvents: 'none',
          animation: 'clickPulse 0.5s ease-out',
          zIndex: 1000
        }} />
      )}
      
      {/* RuneScape-style context menu */}
      {contextMenu.show && (
        <div style={{
          position: 'fixed',
          left: contextMenu.x,
          top: contextMenu.y,
          background: '#c6b895',
          border: '2px outset #d4c4a8',
          borderRadius: '0',
          fontFamily: 'serif',
          fontSize: '12px',
          fontWeight: 'bold',
          color: '#000',
          zIndex: 2000,
          minWidth: '120px',
          boxShadow: '2px 2px 4px rgba(0,0,0,0.5)'
        }}>
          {contextMenu.npc?.userData.type === 'tree' ? (
            <>
              <div 
                onClick={() => handleContextAction('chop', contextMenu.npc)}
                style={{
                  padding: '4px 8px',
                  cursor: 'pointer',
                  borderBottom: '1px solid #a69982'
                }}
                onMouseEnter={(e) => (e.target as HTMLElement).style.background = '#d4c4a8'}
                onMouseLeave={(e) => (e.target as HTMLElement).style.background = 'transparent'}
              >
                Chop Tree
              </div>
              <div 
                onClick={() => handleContextAction('examine', contextMenu.npc)}
                style={{
                  padding: '4px 8px',
                  cursor: 'pointer'
                }}
                onMouseEnter={(e) => (e.target as HTMLElement).style.background = '#d4c4a8'}
                onMouseLeave={(e) => (e.target as HTMLElement).style.background = 'transparent'}
              >
                Examine
              </div>
            </>
          ) : (
            <>
              <div 
                onClick={() => handleContextAction('talk', contextMenu.npc)}
                style={{
                  padding: '4px 8px',
                  cursor: 'pointer',
                  borderBottom: '1px solid #a69982'
                }}
                onMouseEnter={(e) => (e.target as HTMLElement).style.background = '#d4c4a8'}
                onMouseLeave={(e) => (e.target as HTMLElement).style.background = 'transparent'}
              >
                Talk
              </div>
              <div 
                onClick={() => handleContextAction('attack', contextMenu.npc)}
                style={{
                  padding: '4px 8px',
                  cursor: 'pointer',
                  borderBottom: '1px solid #a69982'
                }}
                onMouseEnter={(e) => (e.target as HTMLElement).style.background = '#d4c4a8'}
                onMouseLeave={(e) => (e.target as HTMLElement).style.background = 'transparent'}
              >
                Attack
              </div>
              <div 
                onClick={() => handleContextAction('examine', contextMenu.npc)}
                style={{
                  padding: '4px 8px',
                  cursor: 'pointer'
                }}
                onMouseEnter={(e) => (e.target as HTMLElement).style.background = '#d4c4a8'}
                onMouseLeave={(e) => (e.target as HTMLElement).style.background = 'transparent'}
              >
                Examine
              </div>
            </>
          )}
        </div>
      )}
      
      {/* RuneScape Classic UI */}
      <GameInterface />
      
      {/* Combat UI with floating damage and health bars */}
      <CombatUI 
        floatingTexts={floatingTexts}
        healthBars={healthBars}
        onTextComplete={removeFloatingText}
      />
      {!useMinimalEngine && (
        <div style={{
          position: 'fixed',
          top: '10px',
          left: '10px',
          color: 'white',
          background: 'rgba(0,0,0,0.5)',
          padding: '10px',
          fontFamily: 'monospace'
        }}>
          <p>A/D: Rotate camera</p>
          <p>Left-click: Move/Attack</p>
          <p>Right-click: Context menu</p>
          <p>RuneScape Classic!</p>
        </div>
      )}
      
      {/* CSS for click animation */}
      <style>{`
        @keyframes clickPulse {
          0% {
            transform: scale(0.5);
            opacity: 1;
          }
          100% {
            transform: scale(2);
            opacity: 0;
          }
        }
      `}</style>
    </div>
  );
};

export default Game;
